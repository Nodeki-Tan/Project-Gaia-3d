package core;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.PrintStream;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import core.mapCores.*;
import managers.TileManager;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import mapData.Chunk;
import managers.DisplayManager;
import org.lwjgl.util.vector.Vector3f;
import toolbox.HeightGenerator;
import toolbox.InputHandler;
import toolbox.MapGenerator;
import toolbox.Utils;

public class MapCore implements Runnable{

	public Thread thread;

	//Sub Threads!
	public MapCleanerCore cleanerCore;
	public MapGenACore genACore;
	public MapGenBCore genBCore;
	public MapGenCCore genCCore;
	public MapGenDCore genDCore;

	public static boolean paused = false;
	public static boolean running = false;
	
	public static final int CHUNK_WIDTH = 32;

	public static final int CHUNK_VIEW_HEIGHT = 512 / CHUNK_WIDTH;

	public static final int CHUNK_VIEW_DISTANCE = 10;
	public static final int CHUNK_LOAD_DISTANCE = CHUNK_VIEW_DISTANCE + 2;
	
	private final static Map<String,Chunk> mapData = new ConcurrentHashMap<>();

	//keep track of generated height maps!
	private final static Map<String,float[]> heightData = new ConcurrentHashMap<>();
	private final static Map<String,float[]> biomeData = new ConcurrentHashMap<>();

	static short selectedTile = 1;

	public static int seed = 816153;

	@Override
	public void run() {
        
		long lastTime = DisplayManager.getCurrentTimeNanos();
        double nsPerTick = 1000000000D / 60D;

        int ticks = 0;

        long lastTimer = DisplayManager.getCurrentTimeMilis();
        double delta = 0;

        while (running) {
        	
        	if(!paused) {
        		
	            long now = DisplayManager.getCurrentTimeNanos();
	            delta += (now - lastTime) / nsPerTick;
	            lastTime = now;
	
	            while (delta >= 1) {
	                ticks++;
	                tick();
	                delta -= 1;
	            }
	
	            try {
	                Thread.sleep(2);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	
	            if (DisplayManager.getCurrentTimeMilis() - lastTimer >= 1000) {
	                lastTimer += 1000;
	                System.out.println(
	                		ticks + " MapCore ticks and "
							+ cleanerCore.ticks + " CleanerCore ticks, "
							+ genACore.ticks + " GenACore ticks, " +
							+ genBCore.ticks + " GenBCore ticks, " +
							+ genCCore.ticks + " GenCCore ticks, " +
							+ genDCore.ticks + " GenDCore ticks"
					);
	                ticks = 0;
	            }
        	}
        }
		
		stop();
		
	}
	
	public synchronized void start(){
		thread = new Thread(this);
		running = true;
		thread.start();

		//Start the other cores!(cleaner first)
		cleanerCore = new MapCleanerCore();
		cleanerCore.start();

		genACore = new MapGenACore();
		genBCore = new MapGenBCore();
		genCCore = new MapGenCCore();
		genDCore = new MapGenDCore();

		genACore.start();
		genBCore.start();
		genCCore.start();
		genDCore.start();

	}
	
	public synchronized void stop(){

		//Stop other cores first!
		cleanerCore.running = false;
		genACore.running = false;
		genBCore.running = false;
		genCCore.running = false;
		genDCore.running = false;

		try {
			thread.interrupt();
			thread.join();
		} catch (InterruptedException e) {
			//TODO autogenerated block
		}
	}
	
	public void tick() {

		int posX = (int) RenderCore.camera.getPosition().x / CHUNK_WIDTH;
		int posZ = (int) RenderCore.camera.getPosition().z / CHUNK_WIDTH;

		editTerrain(posX, posZ);
		
	}

	public static void editTerrain(int posX, int posZ) {

		if(InputHandler.isKeyPressed(Keyboard.KEY_I)){
			Mouse.setClipMouseCoordinatesToWindow(true);
			Mouse.setGrabbed(true);
		}

		if(InputHandler.isKeyPressed(Keyboard.KEY_SUBTRACT) && selectedTile - 1 >= 1){
			selectedTile--;
			System.out.println("tile is " + selectedTile);
		}
		
		if(InputHandler.isKeyPressed(Keyboard.KEY_ADD) && selectedTile + 1 <= TileManager.TILE_LIST.size()-1){
			selectedTile++;
			System.out.println("tile is " + selectedTile);
		}
		
		if(InputHandler.isKeyPressed(Keyboard.KEY_F5)){
			
				try {
					saveWorld(posX, posZ);
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			
		}

		if(InputHandler.isMouseButtonPressed(1)) {

			Vector3f collisionPointInMap = RenderCore.camera.ray.checkRayInMap(10, true, true);

			if(collisionPointInMap != null){

				int X = (int) collisionPointInMap.x;
				int Y = (int) collisionPointInMap.y;
				int Z = (int) collisionPointInMap.z;

				System.out.println("mouse clicked in [" + collisionPointInMap + "]");

				setTile(X, Y, Z, selectedTile);

			}

		}

		if(InputHandler.isMouseButtonPressed(0)) {

			Vector3f collisionPointInMap = RenderCore.camera.ray.checkRayInMap(10, false, true);

			if(collisionPointInMap != null){

				int X = (int) collisionPointInMap.x;
				int Y = (int) collisionPointInMap.y;
				int Z = (int) collisionPointInMap.z;

				System.out.println("mouse clicked in [" + collisionPointInMap + "]");

				setTile(X, Y, Z, (short) 0);

			}

		}

	}

	public static boolean loadChunk(int x, int y, int z) {

		File fileDir = new File("saves/" + x + "_" + y + "_" + z + ".Chunk");

		if(fileDir.exists()) {

			short[] data = new short[CHUNK_WIDTH*CHUNK_WIDTH *CHUNK_WIDTH];

			int airBlocks = 0;

			String file = Utils.loadFileAsString("saves/" + x + "_" + y + "_" + z + ".Chunk");

			String[] lines = file.split("_");

			for (int i = 0; i < data.length; i++) {

				data[i] = (short) Utils.parseInt(lines[i]);
				if (data[i] == 0){
					airBlocks++;
				}

			}

			Chunk chunk = new Chunk(data, x, y, z);
			chunk.setAirBlocks(airBlocks);

			mapData.put("" + x + "_" + y + "_" + z + "", chunk);

			System.out.println("loaded the Chunk save file (" + x + "_" + y + "_" + z + ")");

			return true;

		}

		return false;
	}

	public static void saveWorld(int posX, int posZ) throws IOException {

		for(int x = posX - (CHUNK_LOAD_DISTANCE); x < posX + (CHUNK_LOAD_DISTANCE); x++) {
			for(int z = posZ - (CHUNK_LOAD_DISTANCE); z < posZ + (CHUNK_LOAD_DISTANCE); z++) {
				for(int y =  0; y < CHUNK_VIEW_HEIGHT ; y++) {
					saveChunk(x, y, z);
				}
			}
		}

	}

	public static void saveChunk(int x, int y, int z) throws IOException {

		Chunk chunk = mapData.get("" + x + "_" + y + "_" + z + "");

		if(chunk != null) {
			if(!chunk.getSaved()) {

				PrintStream out = new PrintStream(new FileOutputStream ("saves/" + x + "_" + y + "_" + z + ".Chunk"));
				ObjectOutputStream ou = new ObjectOutputStream(out);

				short[] data = chunk.getTiles();

				for (short type: data) {

					ou.writeInt(type);

				}

				ou.close();

				chunk.setSaved();

				System.out.println("updated the Chunk save file (" + x  + "_" + y + "_" + z + ")");

			}
		}

	}

	public static void setTile(int xPos, int yPos, int zPos, short value) {
		float xTile, yTile, zTile;
		
		xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
		yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);
		zTile = zPos + (-(zPos / CHUNK_WIDTH) * CHUNK_WIDTH);
		
		float xChunk, yChunk, zChunk;
		xChunk = (xPos / (float)CHUNK_WIDTH);
		yChunk = (yPos / (float)CHUNK_WIDTH);
		zChunk = (zPos / (float)CHUNK_WIDTH);
		
		if(xChunk < 0) {
			xChunk = (float) Math.floor(xChunk);
		}
		
		if(zChunk < 0) {
			zChunk = (float) Math.floor(zChunk);
		}
		

		if(mapData.containsKey("" + (int)xChunk +"_"+ (int)yChunk +"_"+ (int)zChunk + "")) {
			//System.out.println("Chunk in [" + (int)xChunk + "," + (int)yChunk + "," + (int)zChunk +"]");
			mapData.get("" + (int) xChunk + "_" + (int) yChunk + "_" + (int) zChunk + "").setTile((int) xTile, (int) yTile, (int) zTile, value);
		}

		if (xTile == 0 ){
			if(mapData.containsKey("" + ((int) xChunk - 1) + "_" + (int) yChunk + "_" + (int) zChunk + "")) {
				mapData.get("" + ((int) xChunk - 1) + "_" + (int) yChunk + "_" + (int) zChunk + "").getModel().Update();
			}
		}else if( xTile == CHUNK_WIDTH){
			if(mapData.containsKey("" + ((int) xChunk + 1) + "_" + (int) yChunk + "_" + (int) zChunk + "")) {
				mapData.get("" + ((int) xChunk + 1) + "_" + (int) yChunk + "_" + (int) zChunk + "").getModel().Update();
			}
		}

		if (zTile == 0 ){
			if(mapData.containsKey("" + (int) xChunk + "_" + (int) yChunk + "_" + ((int) zChunk - 1) + "")) {
				mapData.get("" + (int) xChunk + "_" + (int) yChunk + "_" + ((int) zChunk - 1) + "").getModel().Update();
			}
		}else if( zTile == CHUNK_WIDTH){
			if(mapData.containsKey("" + (int) xChunk + "_" + (int) yChunk + "_" + ((int) zChunk + 1) + "")) {
				mapData.get("" + (int) xChunk + "_" + (int) yChunk + "_" + ((int) zChunk + 1) + "").getModel().Update();
			}
		}

		//Here put Y updating check
		if (yTile == 0 ){
			if(mapData.containsKey("" + (int) xChunk + "_" + ((int) yChunk - 1) + "_" + (int) zChunk + "")) {
				mapData.get("" + (int) xChunk + "_" + ((int) yChunk - 1) + "_" + (int) zChunk + "").getModel().Update();
			}
		}else if(yTile == CHUNK_WIDTH){
			if(mapData.containsKey("" + (int) xChunk + "_" + ((int) yChunk + 1) + "_" + ((int) zChunk) + "")) {
				mapData.get("" + (int) xChunk + "_" + ((int) yChunk + 1) + "_" + ((int) zChunk) + "").getModel().Update();
			}
		}

	}
	
	public static short getTile(int xPos, int yPos, int zPos) {
		float xTile, yTile, zTile;

		xTile = xPos + (-(xPos / CHUNK_WIDTH) * CHUNK_WIDTH);
		yTile = yPos + (-(yPos / CHUNK_WIDTH) * CHUNK_WIDTH);
		zTile = zPos + (-(zPos / CHUNK_WIDTH) * CHUNK_WIDTH);

		float xChunk, yChunk, zChunk;
		xChunk = (xPos / (float)CHUNK_WIDTH);
		yChunk = (yPos / (float)CHUNK_WIDTH);
		zChunk = (zPos / (float)CHUNK_WIDTH);

		if(xChunk < 0) {
			xChunk = (float) Math.floor(xChunk);
		}

		if(zChunk < 0) {
			zChunk = (float) Math.floor(zChunk);
		}
		
		//System.out.println("Chunk in [" + (int)xChunk + "," + (int)yChunk + "]");
		if(mapData.containsKey("" + (int)xChunk +"_"+ (int)yChunk +"_"+ (int)zChunk + "")) {
			return mapData.get("" + (int)xChunk +"_"+ (int)yChunk +"_"+ (int)zChunk + "").getTile((int)xTile, (int)yTile, (int)zTile);
		}
		
		return 0;
	}
	
	public static Chunk getMapData(int xPos, int yPos, int zPos) {
		if(chunkExists( xPos, yPos, zPos)){
			return mapData.get("" + xPos +"_"+ yPos +"_"+ zPos + "");
		}

		return null;
	}

	public static boolean chunkExists(int xPos, int yPos, int zPos) {
		return mapData.containsKey("" + xPos +"_"+ yPos +"_"+ zPos + "");
	}

	public static short[] getTileData(int xPos, int yPos, int zPos){
		if(chunkExists( xPos, yPos, zPos)){
			return mapData.get("" + xPos +"_"+ yPos +"_"+ zPos + "").getTiles();
		}

		return null;
	}

	public static void generateData(int x, int z, int posX, int posZ){

		float[] values = heightData.get("" + x + "_" + z + "");
		float[] biomes = biomeData.get("" + x + "_" + z + "");

		if (values == null || biomes == null) {

			biomes = HeightGenerator.GenerateNoiseMap((x * CHUNK_WIDTH) + seed, (z * CHUNK_WIDTH) + seed);
			values = HeightGenerator.GenerateHeightMap((x * CHUNK_WIDTH) + seed, (z * CHUNK_WIDTH) + seed, biomes);

			heightData.put("" + x + "_" + z + "", values);
			biomeData.put("" + x + "_" + z + "", biomes);

		}
		else{

			for (int y = 0; y < CHUNK_VIEW_HEIGHT; y++) {

				Chunk chunk = mapData.get("" + x + "_" + y + "_" + z + "");

				if (chunk == null) {

					if (!loadChunk(x, y, z)) {
						Chunk data = MapGenerator.generateData(x, y, z, values, biomes);

						mapData.put("" + x + "_" + y + "_" + z + "", data);
					}

				}
				else {

					if (x > posX - CHUNK_VIEW_DISTANCE
					&& x < posX + CHUNK_VIEW_DISTANCE
					&& z > posZ - CHUNK_VIEW_DISTANCE
					&& z < posZ + CHUNK_VIEW_DISTANCE) {

						if (!chunk.getRender()) {

							if (mapData.containsKey("" + x + "_" + y + "_" + (z + 1) + "")
							&& mapData.containsKey("" + x + "_" + y + "_" + (z - 1) + "")
							&& mapData.containsKey("" + (x + 1) + "_" + y + "_" + z + "")
							&& mapData.containsKey("" + (x - 1) + "_" + y + "_" + z + "")) {

								if(y  + 1  < CHUNK_VIEW_HEIGHT && y  - 1  > 0) {
									if (mapData.containsKey("" + x + "_" + (y+1) + "_" + z + "")
									&& mapData.containsKey("" +(x + "_" + (y-1) + "_" + z + ""))){
										chunk.createModel();
									}
								}else{
									chunk.createModel();
								}

							}

						}

					}

				}

			}

		}

	}

	public static void cleanData(int posX, int posZ){

		for(Chunk chunk: mapData.values()) {

			int x = (int)chunk.getPosition().x;
			int y = (int)chunk.getPosition().y;
			int z = (int)chunk.getPosition().z;

			if(x < posX - CHUNK_LOAD_DISTANCE
			|| x > posX + CHUNK_LOAD_DISTANCE
			|| z < posZ - CHUNK_LOAD_DISTANCE
			|| z > posZ + CHUNK_LOAD_DISTANCE) {

				if(x < posX - CHUNK_VIEW_DISTANCE
				|| x > posX + CHUNK_VIEW_DISTANCE
				|| z < posZ - CHUNK_VIEW_DISTANCE
				|| z > posZ + CHUNK_VIEW_DISTANCE) {

					if(chunk.getRender()) {
						chunk.destroyModel();
						//System.out.println("destroyed model");
					}

				}

				try {
					saveChunk(x, y, z);
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				heightData.remove("" + x + "_" + z + "");
				biomeData.remove("" + x + "_" + z + "");
				mapData.remove("" + x + "_" + y + "_" + z + "");
				System.out.println("destroyed chunk");

			}

		}

	}

	public static boolean isSolid(int x, int y, int z){

		if(getTile(x,y,z) != 0)
			return true;

		return false;
	}

	public static Map<String,Chunk> getMapData() {
		return mapData;
	}

	public static Map<String,float[]> getHeightData() {
		return heightData;
	}

	public static Map<String,float[]> getBiomeData() {
		return biomeData;
	}

}